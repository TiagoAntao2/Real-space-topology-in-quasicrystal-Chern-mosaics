ITensors.op(::OpName"sigma_plus",::SiteType"Qubit") =
 [0 1
  0 0]

ITensors.op(::OpName"sigma_minus",::SiteType"Qubit") =
 [0 0
  1 0]

function kinetic_1d_nn(L, sites) 
    kinetic = OpSum()
    for i in 1:L
        os = OpSum()
        os += 1,"sigma_plus",L-(i-1)
        for i in 1:L-i 
            os *=  ("Id",i) 
        end
        for i in L+2-i :L 
            os *=  ("sigma_minus",i) 
        end
        kinetic += os
    end
    for i in 1:L
        os = OpSum()
        os += 1,"sigma_minus",L-(i-1)
        for i in 1:L-i 
            os *=  ("Id",i) 
        end
        for i in L+2-i :L 
            os *=  ("sigma_plus",i) 
        end
        kinetic += os
    end
    k_mpo = MPO(kinetic,sites)
    return k_mpo 
end

function kinetic_1d_nn_custom(L, sites, hopping) 

    kinetic_1 = OpSum()
    kinetic_2 = OpSum()
    for i in 1:L
        os = OpSum()
        os += 1,"sigma_plus",L-(i-1)

        for i in 1:L-i 
            os *=  ("Id",i) 
        end
        for i in L+2-i :L 
            os *=  ("sigma_minus",i) 
        end
        
        kinetic_1 += os
    end
    k_mpo_1 = MPO(kinetic_1,sites)
    true_hop_1 = apply(hopping, k_mpo_1)

    for i in 1:L
        os = OpSum()
        os += 1,"sigma_minus",L-(i-1)

        for i in 1:L-i 
            os *=  ("Id",i) 
        end


        for i in L+2-i :L 
            os *=  ("sigma_plus",i) 
        end
        
        kinetic_2 += os
    end
 
    k_mpo_2 = MPO(kinetic_2,sites)
    true_hop_2 = apply(k_mpo_2, hopping)
    k_mpo =  +(true_hop_1, true_hop_2;  cutoff = 1e-8)   
    return k_mpo 
end


function custom_mpo(mps,new_sites)
    #input is 2N MPS generated by QTCI, new_sites are the actual sites of the system
    
    N = length(mps)
    new_N = N ÷ 2
    @assert new_N == length(new_sites) "Failed! Sites must be the same"
    new_mpo = MPO(new_N)
    
    for i in 1:new_N
        idx1 = 2i - 1
        idx2 = 2i
        
         
        A = mps[idx1]
        B = mps[idx2]
        combined_T = A * B
        
     
        old_s1 = siteind(mps, idx1)
        old_s2 = siteind(mps, idx2)
  
        new_s_in = new_sites[i]'
        new_s_out = new_sites[i]
         
        new_mpo[i] = replaceinds(combined_T, [old_s1, old_s2] => [new_s_in, new_s_out])
    end
    return new_mpo
end


function custom_mps(qtt, sites)
    #input is 2N MPS generated by QTCI, new_sites are the actual sites of the system
    
    old_mps = ITensors.MPS(qtt)
    N = length(old_mps)
    println(N)
    new_mps = MPS(N)
    
    for i in 1:N
        A = old_mps[i]
        old_s = siteind(old_mps, i)
        new_s = sites[i]
        new_mps[i] = replaceinds(A, [old_s] => [new_s])
    end
    return new_mps
end

function hopping2MPO(f, N, sites; tol = 1e-8, initial_positions = [], type = Float64)
    # Build quantics grid
    qgrid = QuanticsGrids.DiscretizedGrid{2}(
        Int(log2(N)), (1, 1), (N, N);
        includeendpoint=true,
        unfoldingscheme=:interleaved,
    )


    # Perform cross interpolation directly on f
    if length(initial_positions) > 1
        initialpivots = [QuanticsGrids.origcoord_to_quantics(qgrid, pos)
                         for pos in initial_positions]
        ci, ranks, errors = quanticscrossinterpolate(type, f, qgrid;
                                                     tolerance=tol,
                                                     initialpivots=initialpivots)
    else
        ci, ranks, errors = quanticscrossinterpolate(type, f, qgrid;
                                                     tolerance=tol)
    end

    # Convert to TensorTrain/MPS
    citt = TensorCrossInterpolation.TensorTrain(ci.tci)
    mps = ITensors.MPS(citt)

    println("MPS COMPUTED!")

    # Build MPO
    mpo = custom_mpo(mps, sites)
    println("Turned into MPO!")

    # Truncate
    mpo = ITensorMPS.truncate!(mpo; maxdim=20, cutoff=1e-8)
    return mpo
end

function binary_to_MPS(n, size,sites)
    # Convert to binary string
    binary_str = string(n, base=2)
    
    # Pad the binary string with leading zeros to match the desired size
    padded_binary_str = lpad(binary_str, size, '0')
    
    # Convert the padded string into MPS
    return random_mps(sites,collect(padded_binary_str) |> x -> map(s -> string(s), x))
end


function nearest_hopping_mpo_minus(L,sites)

    kinetic_1 = OpSum()
    for i in 1:L
        os = OpSum()
        os += 1,"sigma_plus",L-(i-1)

        for i in 1:L-i 
            os *=  ("Id",i) 
        end


        for i in L+2-i :L 
            os *=  ("sigma_minus",i) 
        end
        
        kinetic_1 += os
    end
    k_mpo_1 = MPO(kinetic_1,sites)
    return k_mpo_1
end

function nearest_hopping_mpo_plus(L,sites)
    kinetic_2 = OpSum()
    
    for i in 1:L
        os = OpSum()
        os += 1,"sigma_minus",L-(i-1)

        for i in 1:L-i 
            os *=  ("Id",i) 
        end


        for i in L+2-i :L 
            os *=  ("sigma_plus",i) 
        end
        
        kinetic_2 += os
    end
 
    k_mpo_2 = MPO(kinetic_2,sites)
    return k_mpo_2
end


function matrix_checker(mpo, L, sites, i, j)
    psii = binary_to_MPS(Int(i), L,sites)
    psij = binary_to_MPS(Int(j), L,sites)
    return inner(psii,apply(mpo,psij))
end

function mps2mpo(L,sites, density_mps)
    density_mpo = outer(density_mps',density_mps) 
    for i in 1:L
        density_mpo.data[i] =  Quantics._asdiagonal(density_mps.data[i],sites[i])
    end
    return density_mpo
end


function get_diagonal_mpo(L,sites, f; type = Float64)
    xvals = range(1, (2^L); length=2^L)
    qtt, ranks, errors = quanticscrossinterpolate(type, f,  xvals ; tolerance=1e-8)
    tt = TensorCrossInterpolation.tensortrain(qtt.tci)
    density_mps = MPS(tt;sites)
    density_mpo = outer(density_mps',density_mps)
    return mps2mpo(L,sites, density_mps)
end

function filter_MPO(f,xvals,L_chain,num_site,sites)
    qtt, ranks, errors = quanticscrossinterpolate(Float64, f,  xvals; tolerance=1e-8)
    tt = TensorCrossInterpolation.tensortrain(qtt.tci)
    density_mps = MPS(tt;sites)
    density_mpo = outer(density_mps',density_mps) 
    
    for i in 1:Int(log2(num_site))
        density_mpo.data[i] = Quantics._asdiagonal(density_mps.data[i],sites[i])
    end
    
    return density_mpo 
end 


function quasicrystal_modulation_ndeg(i, L, L_chain, k, p)
    center = 2^(L - 1) - L_chain / 2
    center_x = mod((center - 1), L_chain) + 0.5
    center_y = div(center - 1, L_chain) + 0.5
    x = mod((i - 1), L_chain) + 0.5
    y = div(i - 1, L_chain) + 0.5
    x_rel = x - center_x
    y_rel = y - center_y 

    modulation = 0.0
    for n in 0:Int(p/2-1)
        θ = 2π * n / p
        r_proj = x_rel * cos(θ) + y_rel * sin(θ)
        modulation += cos(k * r_proj)
    end

    return modulation
end


function circular_mod(i, L, L_chain, k)
    center = 2^(L - 1) - L_chain / 2
    center_x = mod((center - 1), L_chain) + 0.5
    center_y = div(center - 1, L_chain) + 0.5
    x = mod((i - 1), L_chain) + 0.5
    y = div(i - 1, L_chain) + 0.5
    x_rel = x - center_x
    y_rel = y - center_y 

    modulation = cos(sqrt(x_rel^2+y_rel^2)*k)

    return modulation
end


function qtci_matrix_to_MPO(A_fun, L, sites;
                            tol=1e-8, type=Float64, initial_positions=[])
    # Build quantics grid for a 2^L x 2^L matrix
    Nc = Int(2^L)
    qgrid = QuanticsGrids.DiscretizedGrid{2}(
        L, (1,1), (Nc, Nc);
        includeendpoint=true,
        unfoldingscheme=:interleaved,
    )

    println("got grid!")

    if !isempty(initial_positions)
        initialpivots = [QuanticsGrids.origcoord_to_quantics(qgrid, pos)
                         for pos in initial_positions]
        ci, ranks, errors = quanticscrossinterpolate(
            type, A_fun, qgrid;
            tolerance=tol, initialpivots=initialpivots,
        )
    else
        ci, ranks, errors = quanticscrossinterpolate(
            type, A_fun, qgrid;
            tolerance=tol,
        )
    end

    println("got qtci!")

    # Convert to tensor train
    citt = TensorCrossInterpolation.TensorTrain(ci.tci)

    # Build MPO from tensor train (2L TT cores -> L MPO sites)
    mps = ITensors.MPS(citt)

    println("got MPS!")
    mpo = custom_mpo(mps, sites)

    println("got MPO!")

    # Truncate for safety
    ITensorMPS.truncate!(mpo; maxdim=20, cutoff=1e-8)
    return mpo
end


function Haldane_MPO(l,sites,t2,Φ;M=0.1)
    L = 2*l
    L_chain =2^l 
    num_sites = 2^L

    is_not_extra   = x-> (x!= L_chain*(L_chain-1)+1) &&(x!=L_chain*L_chain)

    break_r_2nd  =  x-> !(x% L_chain == 0 || x%L_chain == L_chain-1)
    break_l_2nd  =  x-> !(x% L_chain == 1 || x%L_chain == 2)

    break_r_1st  =  x-> !(x% L_chain == 0 )
    break_l_1st  =  x-> !(x% L_chain == 1 )


    xvals =range(1, num_sites; length=num_sites)
    
    #excluding edge
    is_B_sub_lattice =  x ->  (x % 2 == 0) && (x!= L_chain*(L_chain-1)+1) &&(x!=L_chain*L_chain) 
    is_A_sub_lattice =  x ->  (x % 2 == 1) && (x!= L_chain*(L_chain-1)+1) &&(x!=L_chain*L_chain) 



    is_A_odd  = x -> is_A_sub_lattice(x) && (( (x+2) ÷ 2) % 2 == 1)
    is_A_even = x -> is_A_sub_lattice(x) && (( (x+2) ÷ 2) % 2 == 0)

    is_B_odd  = x -> is_B_sub_lattice(x) && ((  x ÷ 2) % 2 == 1)
    is_B_even = x -> is_B_sub_lattice(x) && ((  x ÷ 2) % 2 == 0)

    

    is_not_extra_mpo  = filter_MPO(is_not_extra,xvals,L_chain,num_sites,sites)
    break_r_1st_mpo = filter_MPO(break_r_1st,xvals,L_chain,num_sites,sites)
    break_r_2nd_mpo = filter_MPO(break_r_2nd,xvals,L_chain,num_sites,sites)

    break_l_1st_mpo = filter_MPO(break_l_1st,xvals,L_chain,num_sites,sites)
    break_l_2nd_mpo = filter_MPO(break_l_2nd,xvals,L_chain,num_sites,sites)


    is_A_odd_mpo  = filter_MPO(is_A_odd,xvals,L_chain,num_sites,sites)
    is_A_even_mpo = filter_MPO(is_A_even,xvals,L_chain,num_sites,sites)
    is_B_odd_mpo  = filter_MPO(is_B_odd,xvals,L_chain,num_sites,sites)
    is_B_even_mpo = filter_MPO(is_B_even,xvals,L_chain,num_sites,sites)


    k_mpo_p = nearest_hopping_mpo_plus(L,sites)

    up_2     = apply(TopoTN.arbitarty_offline(k_mpo_p,2),break_r_2nd_mpo)
    #note distinction here
    up_Lc_m2 = apply(TopoTN.arbitarty_offline(k_mpo_p,L_chain-2),break_l_2nd_mpo)
    up_Lc    = TopoTN.arbitarty_offline(k_mpo_p,L_chain)
    up_Lc_p2 = apply(TopoTN.arbitarty_offline(k_mpo_p,L_chain+2),break_r_2nd_mpo)
    
    k_mpo_m = nearest_hopping_mpo_minus(L, sites)

    dn_2     = apply(TopoTN.arbitarty_offline(k_mpo_m,2),break_l_2nd_mpo)
    dn_Lc_m2 = apply(TopoTN.arbitarty_offline(k_mpo_m,L_chain-2),break_r_2nd_mpo)
    dn_Lc    = TopoTN.arbitarty_offline(k_mpo_m,L_chain)
    dn_Lc_p2 = apply(TopoTN.arbitarty_offline(k_mpo_m,L_chain+2),break_l_2nd_mpo)

    c2_p  = (cos(Φ) + 1im*sin(Φ))
    c2_m =  (cos(-Φ) + 1im*sin(-Φ))

    # second nearest hopping
    k_A_odd  =  apply( c2_m*(up_2 + up_Lc + dn_2) + c2_p*(up_Lc_m2 + up_Lc_p2 + dn_Lc),is_A_odd_mpo)
    k_A_even =  apply( c2_p*(up_2 + dn_2 + dn_Lc) + c2_m*(dn_Lc_m2 + dn_Lc_p2+ up_Lc), is_A_even_mpo)

    k_B_even  = apply( c2_p*(up_2 + up_Lc + dn_2) +c2_m*( up_Lc_p2 + up_Lc_m2+ dn_Lc),is_B_even_mpo)
    k_B_odd   = apply( c2_m*(up_2 + dn_Lc + dn_2) +c2_p*( up_Lc+ dn_Lc_m2 + dn_Lc_p2),is_B_odd_mpo)

    second_hop =   k_A_odd+k_A_even+k_B_even+k_B_odd

    #nearest hopping 
    up_1     = apply(k_mpo_p,break_r_1st_mpo)
    up_Lc_m1 = TopoTN.arbitarty_offline(k_mpo_p,L_chain-1)
    up_Lc_p1 = TopoTN.arbitarty_offline(k_mpo_p,L_chain+1)


    dn_1     = apply(TopoTN.arbitarty_offline(k_mpo_m,1),break_l_1st_mpo)
    dn_Lc_m1 = TopoTN.arbitarty_offline(k_mpo_m,L_chain-1)
    dn_Lc_p1 = TopoTN.arbitarty_offline(k_mpo_m,L_chain+1)
    

    k_A_odd  = apply(up_1+dn_1+up_Lc_p1,is_A_odd_mpo)
    k_A_even = apply(up_1+dn_1+dn_Lc_m1,is_A_even_mpo)

    k_B_even  = apply(up_1+dn_1+up_Lc_m1,is_B_even_mpo)
    k_B_odd   = apply(up_1+dn_1+dn_Lc_p1,is_B_odd_mpo)


    nearest_hop =  k_A_odd+k_A_even+k_B_even+k_B_odd

    M_h = M_haldane(l,sites)*M
    return (nearest_hop) + t2*(second_hop)+M_h
end

function M_haldane(l,sites)
    L = 2*l
    L_chain = 2^l 
    num_sites = 2^L

    is_not_extra = x -> (x != L_chain*(L_chain-1)+1) && (x != L_chain*L_chain)
    is_B_sub_lattice = x -> (x % 2 == 0) && is_not_extra(x)
    is_A_sub_lattice = x -> (x % 2 == 1) && is_not_extra(x)
    
    function m(x)
        if is_A_sub_lattice(x)
            return -1
        elseif is_B_sub_lattice(x)
            return 1
        else 
            return 0
        end
    end

    xvals =range(1, num_sites; length=num_sites)
    # this gonna cause confusion but filter MPO simply trun a function to mpo; should have defined it based on convert to mpo or define a different methods for convert to mpo
    return filter_MPO(m,xvals,L_chain,num_sites,sites)

end
